#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Convert JSON vulnerabilities dump into pwntools exploit."""

import argparse
import json
import os
import logging

from heapfuzz import Vulnerability


# Get the module logger
module_logger = logging.getLogger(__name__)

# Add a default null handler in case the configuration was not set.
logging.basicConfig(level=logging.INFO)
module_logger.addHandler(logging.NullHandler())


class ExploitWriterError(Exception):
    """Base class for exceptions pertaining to the ExploitWriter class.
    """

    def __init__(self, msg=None):
        if msg is None:
            msg = 'An exception has occurred in the ExploitWriter class.'

        super(Exception, self).__init__(msg)

class BinaryTagNotFoundError(ExploitWriterError):
    """Raised when the binary tag is not found in the template."""

    def __init__(self, msg=None):
        if msg is None:
            msg = 'The {{BINARY}} tag was not found in the provided template.'

        super(ExploitWriterError, self).__init__(msg)


class ExploitCodeTagNotFoundError(ExploitWriterError):
    """Raised when the exploit code tag is not found in the template."""

    def __init__(self, msg=None):
        if msg is None:
            msg = 'The {{EXPLOITCODE}} tag was not found in the provided template.'

        super(ExploitWriterError, self).__init__(msg)


class ExploitWriter:
    """Class to write JSON vulnerabilities to a specified file.

    Args:
        src (file): The source file to read JSON data from.
        dest (str): The path to write resulting exploit file to.
        binary (str): The path of the binary.
        template (file): The template file to use.

    Attributes:
        src (file): The source file to read JSON data from.
        dest (file): The file to write resulting exploit file to.
        template (file): The template file to use.
        vulns (dict): The dictionary containing the vulnerabilities in raw form.
    """

    def __init__(self, src, dest, binary, template):
        self.src = src
        self.dest = dest
        self.binary = binary
        self.template = template


    def to_instructions(self, data):
        """Converts the vulnerability data to instructions.

        Args:
            data (:obj:`list` of :obj:`list`): Contains a list of lists of the form [data, newline,
                sendafter] (e.g. [["1", true, "> "], ["vIaDFd7N", true, "Data: "]])

        Results:
            :obj:`list` of :obj:`str`: A list of the converted instructions.
        """
        instructions = []
        for send_data, newline, send_after in data:
            if send_after is not None:
                instructions.append('p.recvuntil(%s)' % repr(send_after.encode('utf8')))
            if newline:
                instructions.append('p.sendline(%s)' % repr(send_data.encode('utf8')))
            else:
                instructions.append('p.send(%s)' % repr(send_data.encode('utf8')))
        return instructions


    def generate_code(self, indentation, data):
        """Generates the pwntools code.

        Args:
            indentation (int): The number of spaces to prefix each instruction.
            data (:obj:`list` of :obj:`list`): Contains a list of lists of the form [data, newline,
                sendafter] (e.g. [["1", true, "> "], ["vIaDFd7N", true, "Data: "]])

        Returns:
            str: The properly formatted code.
        """
        result = ""
        indents = " " * indentation
        for instruction in self.to_instructions(data):
            result += indents + instruction + "\n"
        result = result.strip()
        return result


    def generate_filename(self, vuln):
        """Generates a filename from the packed vulnerability name.

        Args:
            vuln (str): String representing the vulnerability.

        Returns:
            str: The generated filename.
        """
        vuln_obj = Vulnerability(vuln)
        vuln_type = Vulnerability.vulns[vuln_obj.kind]
        vuln_type = vuln_type.replace(" ", "-")
        vuln_type = vuln_type.lower()
        filename = "%s.%s.%s.%s.py" % (vuln_type, vuln_obj.addr, vuln_obj.orgsize, vuln_obj.newsize)
        return filename


    def execute(self):
        """Method to run the operation."""
        self.vulns = json.load(self.src)

        # Create directory if it does not already exist.
        if not os.path.exists(self.dest):
            os.makedirs(self.dest)

        # Check that the template is valid.
        template_contents = self.template.read()
        if '{{BINARY}}' not in template_contents:
            raise BinaryTagNotFoundError()
        if '{{EXPLOITCODE}}' not in template_contents:
            raise ExploitCodeTagNotFoundError()


        # Determine the indentation.
        for line in template_contents.split("\n"):
            if "{{EXPLOITCODE}}" in line:
                indentation = line.index("{")

        # Template replace binary name
        template_binary_replaced = template_contents.replace("{{BINARY}}", self.binary)

        # Generate the exploit code for each vulnerability.
        for vuln in self.vulns:
            filename = self.generate_filename(vuln)
            exploit_code = self.generate_code(indentation, self.vulns[vuln])
            template_complete = template_binary_replaced.replace("{{EXPLOITCODE}}", exploit_code)
            full_path = os.path.join(self.dest, filename)
            with open(full_path, 'w') as dest_file:
                dest_file.write(template_complete)
                module_logger.info("Wrote to %s" % full_path)


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('src', type=file, help='Source JSON file.')
    parser.add_argument('destdir', help='Directory to output generated exploit files to.')
    parser.add_argument('binary', help='Path to the binary.')
    parser.add_argument('--template', type=file, help='Template file to use.',
                        default='templates/exploit.tpl')
    args = parser.parse_args()
    ew = ExploitWriter(args.src, args.destdir, args.binary,  args.template)
    ew.execute()


if __name__ == '__main__':
    main()
